# ソートアルゴリズム比較表

| ソートアルゴリズム | 計算量 (最良/平均/最悪)              | 安定性    | 概要                                                                                     | 適用場面                                   |
| ------------------ | ------------------------------------ | --------- | ---------------------------------------------------------------------------------------- | ------------------------------------------ |
| **シェルソート**   | O(n log n) / O(n^(3/2)) / O(n^2)     | ❌ 非安定 | 挿入ソートを改良。間隔（ギャップ）を使った効率的なソート。                               | 小規模データセット、ほぼ整列されたデータ   |
| **マージソート**   | O(n log n) / O(n log n) / O(n log n) | ✅ 安定   | 配列を分割し、再帰的にソート後マージ。メモリ使用量多め。番兵（非常に大きな数値）を使う。 | 安定性が必要な場合、大規模データセット     |
| **クイックソート** | O(n log n) / O(n log n) / O(n^2)     | ❌ 非安定 | ピボットを基準に分割統治法でソート。メモリ効率が良い。                                   | 大規模データセット、高速ソートが必要な場合 |

# 各アルゴリズムの詳細

## シェルソート

シェルソートは、挿入ソートを改良したアルゴリズムです。  
配列内の要素を間隔（ギャップ）に基づいて比較・交換を行い、間隔を徐々に縮小しながら最終的にソートします。

### ギャップの役割

ギャップを使うことで、配列内の要素を大きく飛ばして比較します。  
初期のギャップが大きい場合、要素が「おおよそ」正しい位置に配置されます。  
最後にギャップを 1 にして挿入ソートを行うことで、効率的なソートが可能になります。

### ギャップの選択

ギャップは通常、n / 2、n / 4... のように減少させます。  
他のギャップシーケンス（例えば、Hibbard や Knuth のギャップ）を選択することでパフォーマンスを向上させることも可能です。

### 動作原理

配列がほぼ整列されている場合、挿入ソートよりも高速に動作します。  
比較回数が減るため、特に大規模なデータセットで効率的です。

## マージソート

配列を２分割する、を繰り返して比較、その後配列を結合する。  
通常番兵（INF：Infinity）という値を境界に置く。

### 番兵の目的

配列をマージする際、通常は どちらかの配列が空になるまで比較を行う必要があります。  
配列が空になった場合を特別に処理しなければならず、条件分岐が増えてコードが複雑になります。  
番兵を使うことで、この「配列が空になった場合」の処理を省略し、より簡潔に記述できます。

### 番兵の配置

ここでは、配列の末尾に「非常に大きな値（INF）」を追加しています。  
INF は、「入力データの最大値よりも大きな値」として設定され、必ず他の値よりも大きいことが保証されます。

### 動作原理

番兵を使うことで、配列の末尾に到達しても、通常の比較処理を続けることができます。  
例えば、left 配列が [3, 5, INF]、right 配列が [4, 6, INF] であれば、両方の配列の最後には常に INF が存在します。  
INF の比較結果により、もう片方の配列の要素を処理するようになり、どちらか一方が空になったかを特別にチェックする必要がなくなります。

## クイックソート

クイックソートは、分割統治法を基にした高速なソートアルゴリズムです。  
配列の中から ピボット を選び、ピボットを基準に配列を左右に分割します。

### ピボットの役割

ピボットは配列を小さい値の部分と大きい値の部分に分割します。  
適切なピボットの選択がソートの効率に大きく影響します。

### ピボットの選び方

最初の要素: 実装が簡単ですが、入力が偏っている場合に最悪の計算量が発生。  
ランダムな要素: 平均的な性能を保証しやすい。  
中央値近似: 最も効率的ですが、計算コストが高くなる可能性があります。

### 動作原理

再帰的に分割を繰り返し、最終的に要素が1つになるまで処理を行います。  
平均計算量は O(n log n) ですが、ピボット選択が悪い場合、O(n^2) の性能になることがあります。
